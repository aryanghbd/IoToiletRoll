{"ast":null,"code":"'use strict';\n/**\n * Module dependencies\n */\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst Store = require('./store');\n\nconst TopicAliasRecv = require('./topic-alias-recv');\n\nconst TopicAliasSend = require('./topic-alias-send');\n\nconst mqttPacket = require('mqtt-packet');\n\nconst DefaultMessageIdProvider = require('./default-message-id-provider');\n\nconst Writable = require('readable-stream').Writable;\n\nconst inherits = require('inherits');\n\nconst reInterval = require('reinterval');\n\nconst clone = require('rfdc/default');\n\nconst validations = require('./validations');\n\nconst xtend = require('xtend');\n\nconst debug = require('debug')('mqttjs:client');\n\nconst nextTick = process ? process.nextTick : function (callback) {\n  setTimeout(callback, 0);\n};\n\nconst setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  nextTick(callback);\n};\n\nconst defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n};\nconst socketErrors = ['ECONNREFUSED', 'EADDRINUSE', 'ECONNRESET', 'ENOTFOUND']; // Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\nconst errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n};\n\nfunction defaultId() {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n}\n\nfunction applyTopicAlias(client, packet) {\n  if (client.options.protocolVersion === 5) {\n    if (packet.cmd === 'publish') {\n      let alias;\n\n      if (packet.properties) {\n        alias = packet.properties.topicAlias;\n      }\n\n      const topic = packet.topic.toString();\n\n      if (client.topicAliasSend) {\n        if (alias) {\n          if (topic.length !== 0) {\n            // register topic alias\n            debug('applyTopicAlias :: register topic: %s - alias: %d', topic, alias);\n\n            if (!client.topicAliasSend.put(topic, alias)) {\n              debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);\n              return new Error('Sending Topic Alias out of range');\n            }\n          }\n        } else {\n          if (topic.length !== 0) {\n            if (client.options.autoAssignTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic);\n\n              if (alias) {\n                packet.topic = '';\n                packet.properties = { ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto assign(use) topic: %s - alias: %d', topic, alias);\n              } else {\n                alias = client.topicAliasSend.getLruAlias();\n                client.topicAliasSend.put(topic, alias);\n                packet.properties = { ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto assign topic: %s - alias: %d', topic, alias);\n              }\n            } else if (client.options.autoUseTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic);\n\n              if (alias) {\n                packet.topic = '';\n                packet.properties = { ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto use topic: %s - alias: %d', topic, alias);\n              }\n            }\n          }\n        }\n      } else if (alias) {\n        debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);\n        return new Error('Sending Topic Alias out of range');\n      }\n    }\n  }\n}\n\nfunction removeTopicAliasAndRecoverTopicName(client, packet) {\n  let alias;\n\n  if (packet.properties) {\n    alias = packet.properties.topicAlias;\n  }\n\n  let topic = packet.topic.toString();\n\n  if (topic.length === 0) {\n    // restore topic from alias\n    if (typeof alias === 'undefined') {\n      return new Error('Unregistered Topic Alias');\n    } else {\n      topic = client.topicAliasSend.getTopicByAlias(alias);\n\n      if (typeof topic === 'undefined') {\n        return new Error('Unregistered Topic Alias');\n      } else {\n        packet.topic = topic;\n      }\n    }\n  }\n\n  if (alias) {\n    delete packet.properties.topicAlias;\n  }\n}\n\nfunction sendPacket(client, packet, cb) {\n  debug('sendPacket :: packet: %O', packet);\n  debug('sendPacket :: emitting `packetsend`');\n  client.emit('packetsend', packet);\n  debug('sendPacket :: writing to stream');\n  const result = mqttPacket.writeToStream(packet, client.stream, client.options);\n  debug('sendPacket :: writeToStream result %s', result);\n\n  if (!result && cb && cb !== nop) {\n    debug('sendPacket :: handle events on `drain` once through callback.');\n    client.stream.once('drain', cb);\n  } else if (cb) {\n    debug('sendPacket :: invoking cb');\n    cb();\n  }\n}\n\nfunction flush(queue) {\n  if (queue) {\n    debug('flush: queue exists? %b', !!queue);\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed')); // This is suspicious.  Why do we only delete this if we have a callbck?\n        // If this is by-design, then adding no as callback would cause this to get deleted unintentionally.\n\n        delete queue[messageId];\n      }\n    });\n  }\n}\n\nfunction flushVolatile(queue) {\n  if (queue) {\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        delete queue[messageId];\n      }\n    });\n  }\n}\n\nfunction storeAndSend(client, packet, cb, cbStorePut) {\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);\n  let storePacket = packet;\n  let err;\n\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet);\n    err = removeTopicAliasAndRecoverTopicName(client, storePacket);\n\n    if (err) {\n      return cb && cb(err);\n    }\n  }\n\n  client.outgoingStore.put(storePacket, function storedPacket(err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    cbStorePut();\n    sendPacket(client, packet, cb);\n  });\n}\n\nfunction nop(error) {\n  debug('nop ::', error);\n}\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\n\n\nfunction MqttClient(streamBuilder, options) {\n  let k;\n  const that = this;\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options);\n  }\n\n  this.options = options || {}; // Defaults\n\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k];\n    } else {\n      this.options[k] = options[k];\n    }\n  }\n\n  debug('MqttClient :: options.protocol', options.protocol);\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion);\n  debug('MqttClient :: options.username', options.username);\n  debug('MqttClient :: options.keepalive', options.keepalive);\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);\n  debug('MqttClient :: options.topicAliasMaximum', options.topicAliasMaximum);\n  this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n  debug('MqttClient :: clientId', this.options.clientId);\n  this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {\n    arguments[3](0);\n  };\n  this.streamBuilder = streamBuilder;\n  this.messageIdProvider = typeof this.options.messageIdProvider === 'undefined' ? new DefaultMessageIdProvider() : this.options.messageIdProvider; // Inflight message storages\n\n  this.outgoingStore = options.outgoingStore || new Store();\n  this.incomingStore = options.incomingStore || new Store(); // Should QoS zero messages be queued when the connection is broken?\n\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero; // map of subscribed topics to support reconnection\n\n  this._resubscribeTopics = {}; // map of a subscribe messageId and a topic\n\n  this.messageIdToTopic = {}; // Ping timer, setup in _setupPingTimer\n\n  this.pingTimer = null; // Is the client connected?\n\n  this.connected = false; // Are we disconnecting?\n\n  this.disconnecting = false; // Packet queue\n\n  this.queue = []; // connack timer\n\n  this.connackTimer = null; // Reconnect timer\n\n  this.reconnectTimer = null; // Is processing store?\n\n  this._storeProcessing = false; // Packet Ids are put into the store during store processing\n\n  this._packetIdsDuringStoreProcessing = {}; // Store processing queue\n\n  this._storeProcessingQueue = []; // Inflight callbacks\n\n  this.outgoing = {}; // True if connection is first time.\n\n  this._firstConnection = true;\n\n  if (options.topicAliasMaximum > 0) {\n    if (options.topicAliasMaximum > 0xffff) {\n      debug('MqttClient :: options.topicAliasMaximum is out of range');\n    } else {\n      this.topicAliasRecv = new TopicAliasRecv(options.topicAliasMaximum);\n    }\n  } // Send queued packets\n\n\n  this.on('connect', function () {\n    const queue = this.queue;\n\n    function deliver() {\n      const entry = queue.shift();\n      debug('deliver :: entry %o', entry);\n      let packet = null;\n\n      if (!entry) {\n        that._resubscribe();\n\n        return;\n      }\n\n      packet = entry.packet;\n      debug('deliver :: call _sendPacket for %o', packet);\n      let send = true;\n\n      if (packet.messageId && packet.messageId !== 0) {\n        if (!that.messageIdProvider.register(packet.messageId)) {\n          send = false;\n        }\n      }\n\n      if (send) {\n        that._sendPacket(packet, function (err) {\n          if (entry.cb) {\n            entry.cb(err);\n          }\n\n          deliver();\n        });\n      } else {\n        debug('messageId: %d has already used. The message is skipped and removed.', packet.messageId);\n        deliver();\n      }\n    }\n\n    debug('connect :: sending queued packets');\n    deliver();\n  });\n  this.on('close', function () {\n    debug('close :: connected set to `false`');\n    this.connected = false;\n    debug('close :: clearing connackTimer');\n    clearTimeout(this.connackTimer);\n    debug('close :: clearing ping timer');\n\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear();\n      that.pingTimer = null;\n    }\n\n    if (this.topicAliasRecv) {\n      this.topicAliasRecv.clear();\n    }\n\n    debug('close :: calling _setupReconnect');\n\n    this._setupReconnect();\n  });\n  EventEmitter.call(this);\n  debug('MqttClient :: setting up stream');\n\n  this._setupStream();\n}\n\ninherits(MqttClient, EventEmitter);\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\n\nMqttClient.prototype._setupStream = function () {\n  const that = this;\n  const writable = new Writable();\n  const parser = mqttPacket.parser(this.options);\n  let completeParse = null;\n  const packets = [];\n  debug('_setupStream :: calling method to clear reconnect');\n\n  this._clearReconnect();\n\n  debug('_setupStream :: using streamBuilder provided to client to create stream');\n  this.stream = this.streamBuilder(this);\n  parser.on('packet', function (packet) {\n    debug('parser :: on packet push to packets array.');\n    packets.push(packet);\n  });\n\n  function nextTickWork() {\n    if (packets.length) {\n      nextTick(work);\n    } else {\n      const done = completeParse;\n      completeParse = null;\n      done();\n    }\n  }\n\n  function work() {\n    debug('work :: getting next packet in queue');\n    const packet = packets.shift();\n\n    if (packet) {\n      debug('work :: packet pulled from queue');\n\n      that._handlePacket(packet, nextTickWork);\n    } else {\n      debug('work :: no packets in queue');\n      const done = completeParse;\n      completeParse = null;\n      debug('work :: done flag is %s', !!done);\n      if (done) done();\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done;\n    debug('writable stream :: parsing buffer');\n    parser.parse(buf);\n    work();\n  };\n\n  function streamErrorHandler(error) {\n    debug('streamErrorHandler :: error', error.message);\n\n    if (socketErrors.includes(error.code)) {\n      // handle error\n      debug('streamErrorHandler :: emitting error');\n      that.emit('error', error);\n    } else {\n      nop(error);\n    }\n  }\n\n  debug('_setupStream :: pipe stream to writable stream');\n  this.stream.pipe(writable); // Suppress connection errors\n\n  this.stream.on('error', streamErrorHandler); // Echo stream close\n\n  this.stream.on('close', function () {\n    debug('(%s)stream :: on close', that.options.clientId);\n    flushVolatile(that.outgoing);\n    debug('stream: emit close to MqttClient');\n    that.emit('close');\n  }); // Send a connect packet\n\n  debug('_setupStream: sending packet `connect`');\n  const connectPacket = Object.create(this.options);\n  connectPacket.cmd = 'connect';\n\n  if (this.topicAliasRecv) {\n    if (!connectPacket.properties) {\n      connectPacket.properties = {};\n    }\n\n    if (this.topicAliasRecv) {\n      connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max;\n    }\n  } // avoid message queue\n\n\n  sendPacket(this, connectPacket); // Echo connection errors\n\n  parser.on('error', this.emit.bind(this, 'error')); // auth\n\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      that.end(() => this.emit('error', new Error('Packet has no Authentication Method')));\n      return this;\n    }\n\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      const authPacket = xtend({\n        cmd: 'auth',\n        reasonCode: 0\n      }, this.options.authPacket);\n      sendPacket(this, authPacket);\n    }\n  } // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n\n\n  this.stream.setMaxListeners(1000);\n  clearTimeout(this.connackTimer);\n  this.connackTimer = setTimeout(function () {\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`');\n\n    that._cleanUp(true);\n  }, this.options.connectTimeout);\n};\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  const options = this.options;\n\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n    this.end({\n      reasonCode: 149,\n      properties: {\n        reasonString: 'Maximum packet size was exceeded'\n      }\n    });\n    return this;\n  }\n\n  debug('_handlePacket :: emitting packetreceive');\n  this.emit('packetreceive', packet);\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done);\n\n      break;\n\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet);\n\n      done();\n      break;\n\n    case 'pubrel':\n      this._handlePubrel(packet, done);\n\n      break;\n\n    case 'connack':\n      this._handleConnack(packet);\n\n      done();\n      break;\n\n    case 'auth':\n      this._handleAuth(packet);\n\n      done();\n      break;\n\n    case 'pingresp':\n      this._handlePingresp(packet);\n\n      done();\n      break;\n\n    case 'disconnect':\n      this._handleDisconnect(packet);\n\n      done();\n      break;\n\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break;\n  }\n};\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback && callback !== nop) {\n      callback(new Error('client disconnecting'));\n    } else {\n      this.emit('error', new Error('client disconnecting'));\n    }\n  }\n\n  return this.disconnecting;\n};\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\n\n\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  debug('publish :: message `%s` to topic `%s`', message, topic);\n  const options = this.options; // .publish(topic, payload, cb);\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  } // default opts\n\n\n  const defaultOpts = {\n    qos: 0,\n    retain: false,\n    dup: false\n  };\n  opts = xtend(defaultOpts, opts);\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  const that = this;\n\n  const publishProc = function () {\n    let messageId = 0;\n\n    if (opts.qos === 1 || opts.qos === 2) {\n      messageId = that._nextId();\n\n      if (messageId === null) {\n        debug('No messageId left');\n        return false;\n      }\n    }\n\n    const packet = {\n      cmd: 'publish',\n      topic: topic,\n      payload: message,\n      qos: opts.qos,\n      retain: opts.retain,\n      messageId: messageId,\n      dup: opts.dup\n    };\n\n    if (options.protocolVersion === 5) {\n      packet.properties = opts.properties;\n    }\n\n    debug('publish :: qos', opts.qos);\n\n    switch (opts.qos) {\n      case 1:\n      case 2:\n        // Add to callbacks\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: callback || nop\n        };\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n\n        that._sendPacket(packet, undefined, opts.cbStorePut);\n\n        break;\n\n      default:\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n\n        that._sendPacket(packet, callback, opts.cbStorePut);\n\n        break;\n    }\n\n    return true;\n  };\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {\n    this._storeProcessingQueue.push({\n      invoke: publishProc,\n      cbStorePut: opts.cbStorePut,\n      callback: callback\n    });\n  }\n\n  return this;\n};\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n * @example client.subscribe('topic', console.log);\n */\n\n\nMqttClient.prototype.subscribe = function () {\n  const that = this;\n  const args = new Array(arguments.length);\n\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  const subs = [];\n  let obj = args.shift();\n  const resubscribe = obj.resubscribe;\n  let callback = args.pop() || nop;\n  let opts = args.pop();\n  const version = this.options.protocolVersion;\n  delete obj.resubscribe;\n\n  if (typeof obj === 'string') {\n    obj = [obj];\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n\n  const invalidTopic = validations.validateTopics(obj);\n\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    debug('subscribe: discconecting true');\n    return this;\n  }\n\n  const defaultOpts = {\n    qos: 0\n  };\n\n  if (version === 5) {\n    defaultOpts.nl = false;\n    defaultOpts.rap = false;\n    defaultOpts.rh = 0;\n  }\n\n  opts = xtend(defaultOpts, opts);\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      debug('subscribe: array topic %s', topic);\n\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {\n        const currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        };\n\n        if (version === 5) {\n          currentOpts.nl = opts.nl;\n          currentOpts.rap = opts.rap;\n          currentOpts.rh = opts.rh;\n          currentOpts.properties = opts.properties;\n        }\n\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);\n        subs.push(currentOpts);\n      }\n    });\n  } else {\n    Object.keys(obj).forEach(function (k) {\n      debug('subscribe: object topic %s', k);\n\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {\n        const currentOpts = {\n          topic: k,\n          qos: obj[k].qos\n        };\n\n        if (version === 5) {\n          currentOpts.nl = obj[k].nl;\n          currentOpts.rap = obj[k].rap;\n          currentOpts.rh = obj[k].rh;\n          currentOpts.properties = opts.properties;\n        }\n\n        debug('subscribe: pushing `%s` to subs list', currentOpts);\n        subs.push(currentOpts);\n      }\n    });\n  }\n\n  if (!subs.length) {\n    callback(null, []);\n    return this;\n  }\n\n  const subscribeProc = function () {\n    const messageId = that._nextId();\n\n    if (messageId === null) {\n      debug('No messageId left');\n      return false;\n    }\n\n    const packet = {\n      cmd: 'subscribe',\n      subscriptions: subs,\n      qos: 1,\n      retain: false,\n      dup: false,\n      messageId: messageId\n    };\n\n    if (opts.properties) {\n      packet.properties = opts.properties;\n    } // subscriptions to resubscribe to in case of disconnect\n\n\n    if (that.options.resubscribe) {\n      debug('subscribe :: resubscribe true');\n      const topics = [];\n      subs.forEach(function (sub) {\n        if (that.options.reconnectPeriod > 0) {\n          const topic = {\n            qos: sub.qos\n          };\n\n          if (version === 5) {\n            topic.nl = sub.nl || false;\n            topic.rap = sub.rap || false;\n            topic.rh = sub.rh || 0;\n            topic.properties = sub.properties;\n          }\n\n          that._resubscribeTopics[sub.topic] = topic;\n          topics.push(sub.topic);\n        }\n      });\n      that.messageIdToTopic[packet.messageId] = topics;\n    }\n\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: function (err, packet) {\n        if (!err) {\n          const granted = packet.granted;\n\n          for (let i = 0; i < granted.length; i += 1) {\n            subs[i].qos = granted[i];\n          }\n        }\n\n        callback(err, subs);\n      }\n    };\n    debug('subscribe :: call _sendPacket');\n\n    that._sendPacket(packet);\n\n    return true;\n  };\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {\n    this._storeProcessingQueue.push({\n      invoke: subscribeProc,\n      callback: callback\n    });\n  }\n\n  return this;\n};\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Object} properties - properties of unsubscribe packet\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\n\n\nMqttClient.prototype.unsubscribe = function () {\n  const that = this;\n  const args = new Array(arguments.length);\n\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  let topic = args.shift();\n  let callback = args.pop() || nop;\n  let opts = args.pop();\n\n  if (typeof topic === 'string') {\n    topic = [topic];\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n\n  const invalidTopic = validations.validateTopics(topic);\n\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n\n  if (that._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  const unsubscribeProc = function () {\n    const messageId = that._nextId();\n\n    if (messageId === null) {\n      debug('No messageId left');\n      return false;\n    }\n\n    const packet = {\n      cmd: 'unsubscribe',\n      qos: 1,\n      messageId: messageId\n    };\n\n    if (typeof topic === 'string') {\n      packet.unsubscriptions = [topic];\n    } else if (Array.isArray(topic)) {\n      packet.unsubscriptions = topic;\n    }\n\n    if (that.options.resubscribe) {\n      packet.unsubscriptions.forEach(function (topic) {\n        delete that._resubscribeTopics[topic];\n      });\n    }\n\n    if (typeof opts === 'object' && opts.properties) {\n      packet.properties = opts.properties;\n    }\n\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: callback\n    };\n    debug('unsubscribe: call _sendPacket');\n\n    that._sendPacket(packet);\n\n    return true;\n  };\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {\n    this._storeProcessingQueue.push({\n      invoke: unsubscribeProc,\n      callback: callback\n    });\n  }\n\n  return this;\n};\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Object} opts - added to the disconnect packet\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\n\n\nMqttClient.prototype.end = function (force, opts, cb) {\n  const that = this;\n  debug('end :: (%s)', this.options.clientId);\n\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop;\n    opts = force;\n    force = false;\n\n    if (typeof opts !== 'object') {\n      cb = opts;\n      opts = null;\n\n      if (typeof cb !== 'function') {\n        cb = nop;\n      }\n    }\n  }\n\n  if (typeof opts !== 'object') {\n    cb = opts;\n    opts = null;\n  }\n\n  debug('end :: cb? %s', !!cb);\n  cb = cb || nop;\n\n  function closeStores() {\n    debug('end :: closeStores: closing incoming and outgoing stores');\n    that.disconnected = true;\n    that.incomingStore.close(function (e1) {\n      that.outgoingStore.close(function (e2) {\n        debug('end :: closeStores: emitting end');\n        that.emit('end');\n\n        if (cb) {\n          const err = e1 || e2;\n          debug('end :: closeStores: invoking callback with args');\n          cb(err);\n        }\n      });\n    });\n\n    if (that._deferredReconnect) {\n      that._deferredReconnect();\n    }\n  }\n\n  function finish() {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force);\n\n    that._cleanUp(force, () => {\n      debug('end :: finish :: calling process.nextTick on closeStores'); // const boundProcess = nextTick.bind(null, closeStores)\n\n      nextTick(closeStores.bind(that));\n    }, opts);\n  }\n\n  if (this.disconnecting) {\n    cb();\n    return this;\n  }\n\n  this._clearReconnect();\n\n  this.disconnecting = true;\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId);\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n  } else {\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId);\n    finish();\n  }\n\n  return this;\n};\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} messageId - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastAllocated());\n */\n\n\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  delete this.outgoing[messageId];\n  this.outgoingStore.del({\n    messageId: messageId\n  }, function () {\n    cb(new Error('Message removed'));\n  });\n  return this;\n};\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\n\n\nMqttClient.prototype.reconnect = function (opts) {\n  debug('client reconnect');\n  const that = this;\n\n  const f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore;\n      that.options.outgoingStore = opts.outgoingStore;\n    } else {\n      that.options.incomingStore = null;\n      that.options.outgoingStore = null;\n    }\n\n    that.incomingStore = that.options.incomingStore || new Store();\n    that.outgoingStore = that.options.outgoingStore || new Store();\n    that.disconnecting = false;\n    that.disconnected = false;\n    that._deferredReconnect = null;\n\n    that._reconnect();\n  };\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f;\n  } else {\n    f();\n  }\n\n  return this;\n};\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\n\n\nMqttClient.prototype._reconnect = function () {\n  debug('_reconnect: emitting reconnect to client');\n  this.emit('reconnect');\n\n  if (this.connected) {\n    this.end(() => {\n      this._setupStream();\n    });\n    debug('client already connected. disconnecting first.');\n  } else {\n    debug('_reconnect: calling _setupStream');\n\n    this._setupStream();\n  }\n};\n/**\n * _setupReconnect - setup reconnect timer\n */\n\n\nMqttClient.prototype._setupReconnect = function () {\n  const that = this;\n\n  if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n    if (!this.reconnecting) {\n      debug('_setupReconnect :: emit `offline` state');\n      this.emit('offline');\n      debug('_setupReconnect :: set `reconnecting` to `true`');\n      this.reconnecting = true;\n    }\n\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod);\n    that.reconnectTimer = setInterval(function () {\n      debug('reconnectTimer :: reconnect triggered!');\n\n      that._reconnect();\n    }, that.options.reconnectPeriod);\n  } else {\n    debug('_setupReconnect :: doing nothing...');\n  }\n};\n/**\n * _clearReconnect - clear the reconnect timer\n */\n\n\nMqttClient.prototype._clearReconnect = function () {\n  debug('_clearReconnect : clearing reconnect timer');\n\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer);\n    this.reconnectTimer = null;\n  }\n};\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\n\n\nMqttClient.prototype._cleanUp = function (forced, done) {\n  const opts = arguments[2];\n\n  if (done) {\n    debug('_cleanUp :: done callback provided for on stream close');\n    this.stream.on('close', done);\n  }\n\n  debug('_cleanUp :: forced? %s', forced);\n\n  if (forced) {\n    if (this.options.reconnectPeriod === 0 && this.options.clean) {\n      flush(this.outgoing);\n    }\n\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId);\n    this.stream.destroy();\n  } else {\n    const packet = xtend({\n      cmd: 'disconnect'\n    }, opts);\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);\n\n    this._sendPacket(packet, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n  }\n\n  if (!this.disconnecting) {\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');\n\n    this._clearReconnect();\n\n    this._setupReconnect();\n  }\n\n  if (this.pingTimer !== null) {\n    debug('_cleanUp :: clearing pingTimer');\n    this.pingTimer.clear();\n    this.pingTimer = null;\n  }\n\n  if (done && !this.connected) {\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);\n    this.stream.removeListener('close', done);\n    done();\n  }\n};\n/**\n * _sendPacket - send or queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\n\n\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId);\n  cbStorePut = cbStorePut || nop;\n  cb = cb || nop;\n  const err = applyTopicAlias(this, packet);\n\n  if (err) {\n    cb(err);\n    return;\n  }\n\n  if (!this.connected) {\n    // allow auth packets to be sent while authenticating with the broker (mqtt5 enhanced auth)\n    if (packet.cmd === 'auth') {\n      this._shiftPingInterval();\n\n      sendPacket(this, packet, cb);\n      return;\n    }\n\n    debug('_sendPacket :: client not connected. Storing packet offline.');\n\n    this._storePacket(packet, cb, cbStorePut);\n\n    return;\n  } // When sending a packet, reschedule the ping timer\n\n\n  this._shiftPingInterval();\n\n  switch (packet.cmd) {\n    case 'publish':\n      break;\n\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut);\n      return;\n\n    default:\n      sendPacket(this, packet, cb);\n      return;\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut);\n      break;\n\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n\n    case 0:\n    /* falls through */\n\n    default:\n      sendPacket(this, packet, cb);\n      break;\n  }\n\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId);\n};\n/**\n * _storePacket - queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\n\n\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  debug('_storePacket :: packet: %o', packet);\n  debug('_storePacket :: cb? %s', !!cb);\n  cbStorePut = cbStorePut || nop;\n  let storePacket = packet;\n\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet);\n    const err = removeTopicAliasAndRecoverTopicName(this, storePacket);\n\n    if (err) {\n      return cb && cb(err);\n    }\n  } // check that the packet is not a qos of 0, or that the command is not a publish\n\n\n  if ((storePacket.qos || 0) === 0 && this.queueQoSZero || storePacket.cmd !== 'publish') {\n    this.queue.push({\n      packet: storePacket,\n      cb: cb\n    });\n  } else if (storePacket.qos > 0) {\n    cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null;\n    this.outgoingStore.put(storePacket, function (err) {\n      if (err) {\n        return cb && cb(err);\n      }\n\n      cbStorePut();\n    });\n  } else if (cb) {\n    cb(new Error('No connection to broker'));\n  }\n};\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\n\n\nMqttClient.prototype._setupPingTimer = function () {\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);\n  const that = this;\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true;\n    this.pingTimer = reInterval(function () {\n      that._checkPing();\n    }, this.options.keepalive * 1000);\n  }\n};\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\n\n\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000);\n  }\n};\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\n\n\nMqttClient.prototype._checkPing = function () {\n  debug('_checkPing :: checking ping...');\n\n  if (this.pingResp) {\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`');\n    this.pingResp = false;\n\n    this._sendPacket({\n      cmd: 'pingreq'\n    });\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    debug('_checkPing :: calling _cleanUp with force true');\n\n    this._cleanUp(true);\n  }\n};\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\n\n\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true;\n};\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handleConnack = function (packet) {\n  debug('_handleConnack');\n  const options = this.options;\n  const version = options.protocolVersion;\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode;\n  clearTimeout(this.connackTimer);\n  delete this.topicAliasSend;\n\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (packet.properties.topicAliasMaximum > 0xffff) {\n        this.emit('error', new Error('topicAliasMaximum from broker is out of range'));\n        return;\n      }\n\n      if (packet.properties.topicAliasMaximum > 0) {\n        this.topicAliasSend = new TopicAliasSend(packet.properties.topicAliasMaximum);\n      }\n    }\n\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive;\n\n      this._shiftPingInterval();\n    }\n\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) {\n        options.properties = {};\n      }\n\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n    }\n  }\n\n  if (rc === 0) {\n    this.reconnecting = false;\n\n    this._onConnect(packet);\n  } else if (rc > 0) {\n    const err = new Error('Connection refused: ' + errors[rc]);\n    err.code = rc;\n    this.emit('error', err);\n  }\n};\n\nMqttClient.prototype._handleAuth = function (packet) {\n  const options = this.options;\n  const version = options.protocolVersion;\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode;\n\n  if (version !== 5) {\n    const err = new Error('Protocol error: Auth packets are only supported in MQTT 5. Your version:' + version);\n    err.code = rc;\n    this.emit('error', err);\n    return;\n  }\n\n  const that = this;\n  this.handleAuth(packet, function (err, packet) {\n    if (err) {\n      that.emit('error', err);\n      return;\n    }\n\n    if (rc === 24) {\n      that.reconnecting = false;\n\n      that._sendPacket(packet);\n    } else {\n      const error = new Error('Connection refused: ' + errors[rc]);\n      err.code = rc;\n      that.emit('error', error);\n    }\n  });\n};\n/**\n * @param packet the packet received by the broker\n * @return the auth packet to be returned to the broker\n * @api public\n */\n\n\nMqttClient.prototype.handleAuth = function (packet, callback) {\n  callback();\n};\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: messageId\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\n\n\nMqttClient.prototype._handlePublish = function (packet, done) {\n  debug('_handlePublish: packet %o', packet);\n  done = typeof done !== 'undefined' ? done : nop;\n  let topic = packet.topic.toString();\n  const message = packet.payload;\n  const qos = packet.qos;\n  const messageId = packet.messageId;\n  const that = this;\n  const options = this.options;\n  const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n\n  if (this.options.protocolVersion === 5) {\n    let alias;\n\n    if (packet.properties) {\n      alias = packet.properties.topicAlias;\n    }\n\n    if (typeof alias !== 'undefined') {\n      if (topic.length === 0) {\n        if (alias > 0 && alias <= 0xffff) {\n          const gotTopic = this.topicAliasRecv.getTopicByAlias(alias);\n\n          if (gotTopic) {\n            topic = gotTopic;\n            debug('_handlePublish :: topic complemented by alias. topic: %s - alias: %d', topic, alias);\n          } else {\n            debug('_handlePublish :: unregistered topic alias. alias: %d', alias);\n            this.emit('error', new Error('Received unregistered Topic Alias'));\n            return;\n          }\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias);\n          this.emit('error', new Error('Received Topic Alias is out of range'));\n          return;\n        }\n      } else {\n        if (this.topicAliasRecv.put(topic, alias)) {\n          debug('_handlePublish :: registered topic: %s - alias: %d', topic, alias);\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias);\n          this.emit('error', new Error('Received Topic Alias is out of range'));\n          return;\n        }\n      }\n    }\n  }\n\n  debug('_handlePublish: qos %d', qos);\n\n  switch (qos) {\n    case 2:\n      {\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n\n          if (error) {\n            return that.emit('error', error);\n          }\n\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for pubrec'));\n          }\n\n          if (code) {\n            that._sendPacket({\n              cmd: 'pubrec',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          } else {\n            that.incomingStore.put(packet, function () {\n              that._sendPacket({\n                cmd: 'pubrec',\n                messageId: messageId\n              }, done);\n            });\n          }\n        });\n        break;\n      }\n\n    case 1:\n      {\n        // emit the message event\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n\n          if (error) {\n            return that.emit('error', error);\n          }\n\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for puback'));\n          }\n\n          if (!code) {\n            that.emit('message', topic, message, packet);\n          }\n\n          that.handleMessage(packet, function (err) {\n            if (err) {\n              return done && done(err);\n            }\n\n            that._sendPacket({\n              cmd: 'puback',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          });\n        });\n        break;\n      }\n\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet);\n      this.handleMessage(packet, done);\n      break;\n\n    default:\n      // do nothing\n      debug('_handlePublish: unknown QoS. Doing nothing.'); // log or throw an error about unknown qos\n\n      break;\n  }\n};\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\n\n\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback();\n};\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  const messageId = packet.messageId;\n  const type = packet.cmd;\n  let response = null;\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  const that = this;\n  let err;\n\n  if (!cb || cb === nop) {\n    debug('_handleAck :: Server sent an ack in error. Ignoring.'); // Server sent an ack in error, ignore it.\n\n    return;\n  } // Process\n\n\n  debug('_handleAck :: packet type', type);\n\n  switch (type) {\n    case 'pubcomp': // same thing as puback for QoS 2\n\n    case 'puback':\n      {\n        const pubackRC = packet.reasonCode; // Callback - we're done\n\n        if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n          err = new Error('Publish error: ' + errors[pubackRC]);\n          err.code = pubackRC;\n          cb(err, packet);\n        }\n\n        delete this.outgoing[messageId];\n        this.outgoingStore.del(packet, cb);\n        this.messageIdProvider.deallocate(messageId);\n\n        this._invokeStoreProcessingQueue();\n\n        break;\n      }\n\n    case 'pubrec':\n      {\n        response = {\n          cmd: 'pubrel',\n          qos: 2,\n          messageId: messageId\n        };\n        const pubrecRC = packet.reasonCode;\n\n        if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n          err = new Error('Publish error: ' + errors[pubrecRC]);\n          err.code = pubrecRC;\n          cb(err, packet);\n        } else {\n          this._sendPacket(response);\n        }\n\n        break;\n      }\n\n    case 'suback':\n      {\n        delete this.outgoing[messageId];\n        this.messageIdProvider.deallocate(messageId);\n\n        for (let grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n          if ((packet.granted[grantedI] & 0x80) !== 0) {\n            // suback with Failure status\n            const topics = this.messageIdToTopic[messageId];\n\n            if (topics) {\n              topics.forEach(function (topic) {\n                delete that._resubscribeTopics[topic];\n              });\n            }\n          }\n        }\n\n        this._invokeStoreProcessingQueue();\n\n        cb(null, packet);\n        break;\n      }\n\n    case 'unsuback':\n      {\n        delete this.outgoing[messageId];\n        this.messageIdProvider.deallocate(messageId);\n\n        this._invokeStoreProcessingQueue();\n\n        cb(null);\n        break;\n      }\n\n    default:\n      that.emit('error', new Error('unrecognized packet type'));\n  }\n\n  if (this.disconnecting && Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty');\n  }\n};\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  debug('handling pubrel packet');\n  callback = typeof callback !== 'undefined' ? callback : nop;\n  const messageId = packet.messageId;\n  const that = this;\n  const comp = {\n    cmd: 'pubcomp',\n    messageId: messageId\n  };\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub);\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        that.incomingStore.del(pub, nop);\n\n        that._sendPacket(comp, callback);\n      });\n    } else {\n      that._sendPacket(comp, callback);\n    }\n  });\n};\n/**\n * _handleDisconnect\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet);\n};\n/**\n * _nextId\n * @return unsigned int\n */\n\n\nMqttClient.prototype._nextId = function () {\n  return this.messageIdProvider.allocate();\n};\n/**\n * getLastMessageId\n * @return unsigned int\n */\n\n\nMqttClient.prototype.getLastMessageId = function () {\n  return this.messageIdProvider.getLastAllocated();\n};\n/**\n * _resubscribe\n * @api private\n */\n\n\nMqttClient.prototype._resubscribe = function () {\n  debug('_resubscribe');\n\n  const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n\n  if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent) && _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        debug('_resubscribe: protocolVersion 5');\n\n        for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          const resubscribeTopic = {};\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n          resubscribeTopic.resubscribe = true;\n          this.subscribe(resubscribeTopic, {\n            properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties\n          });\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true;\n        this.subscribe(this._resubscribeTopics);\n      }\n    } else {\n      this._resubscribeTopics = {};\n    }\n  }\n\n  this._firstConnection = false;\n};\n/**\n * _onConnect\n *\n * @api private\n */\n\n\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet);\n    return;\n  }\n\n  const that = this;\n  this.connackPacket = packet;\n  this.messageIdProvider.clear();\n\n  this._setupPingTimer();\n\n  this.connected = true;\n\n  function startStreamProcess() {\n    let outStore = that.outgoingStore.createStream();\n\n    function clearStoreProcessing() {\n      that._storeProcessing = false;\n      that._packetIdsDuringStoreProcessing = {};\n    }\n\n    that.once('close', remove);\n    outStore.on('error', function (err) {\n      clearStoreProcessing();\n\n      that._flushStoreProcessingQueue();\n\n      that.removeListener('close', remove);\n      that.emit('error', err);\n    });\n\n    function remove() {\n      outStore.destroy();\n      outStore = null;\n\n      that._flushStoreProcessingQueue();\n\n      clearStoreProcessing();\n    }\n\n    function storeDeliver() {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return;\n      }\n\n      that._storeProcessing = true;\n      const packet = outStore.read(1);\n      let cb;\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver);\n        return;\n      } // Skip already processed store packets\n\n\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver();\n        return;\n      } // Avoid unnecessary stream read operations when disconnected\n\n\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status);\n            }\n\n            storeDeliver();\n          }\n        };\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n\n        if (that.messageIdProvider.register(packet.messageId)) {\n          that._sendPacket(packet);\n        } else {\n          debug('messageId: %d has already used.', packet.messageId);\n        }\n      } else if (outStore.destroy) {\n        outStore.destroy();\n      }\n    }\n\n    outStore.on('end', function () {\n      let allProcessed = true;\n\n      for (const id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false;\n          break;\n        }\n      }\n\n      if (allProcessed) {\n        clearStoreProcessing();\n        that.removeListener('close', remove);\n\n        that._invokeAllStoreProcessingQueue();\n\n        that.emit('connect', packet);\n      } else {\n        startStreamProcess();\n      }\n    });\n    storeDeliver();\n  } // start flowing\n\n\n  startStreamProcess();\n};\n\nMqttClient.prototype._invokeStoreProcessingQueue = function () {\n  if (this._storeProcessingQueue.length > 0) {\n    const f = this._storeProcessingQueue[0];\n\n    if (f && f.invoke()) {\n      this._storeProcessingQueue.shift();\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nMqttClient.prototype._invokeAllStoreProcessingQueue = function () {\n  while (this._invokeStoreProcessingQueue()) {\n    /* empty */\n  }\n};\n\nMqttClient.prototype._flushStoreProcessingQueue = function () {\n  for (const f of this._storeProcessingQueue) {\n    if (f.cbStorePut) f.cbStorePut(new Error('Connection closed'));\n    if (f.callback) f.callback(new Error('Connection closed'));\n  }\n\n  this._storeProcessingQueue.splice(0);\n};\n\nmodule.exports = MqttClient;","map":{"version":3,"sources":["/Users/hollysolomon/Documents/year3/EmbeddedSys/EmbeddedSystems22/webapp/MERN-stack-login-authentication/node_modules/mqtt/lib/client.js"],"names":["EventEmitter","require","Store","TopicAliasRecv","TopicAliasSend","mqttPacket","DefaultMessageIdProvider","Writable","inherits","reInterval","clone","validations","xtend","debug","nextTick","process","callback","setTimeout","setImmediate","global","defaultConnectOptions","keepalive","reschedulePings","protocolId","protocolVersion","reconnectPeriod","connectTimeout","clean","resubscribe","socketErrors","errors","defaultId","Math","random","toString","substr","applyTopicAlias","client","packet","options","cmd","alias","properties","topicAlias","topic","topicAliasSend","length","put","Error","autoAssignTopicAlias","getAliasByTopic","getLruAlias","autoUseTopicAlias","removeTopicAliasAndRecoverTopicName","getTopicByAlias","sendPacket","cb","emit","result","writeToStream","stream","nop","once","flush","queue","Object","keys","forEach","messageId","flushVolatile","volatile","storeAndSend","cbStorePut","storePacket","err","outgoingStore","storedPacket","error","MqttClient","streamBuilder","k","that","protocol","username","rejectUnauthorized","topicAliasMaximum","clientId","customHandleAcks","arguments","messageIdProvider","incomingStore","queueQoSZero","undefined","_resubscribeTopics","messageIdToTopic","pingTimer","connected","disconnecting","connackTimer","reconnectTimer","_storeProcessing","_packetIdsDuringStoreProcessing","_storeProcessingQueue","outgoing","_firstConnection","topicAliasRecv","on","deliver","entry","shift","_resubscribe","send","register","_sendPacket","clearTimeout","clear","_setupReconnect","call","_setupStream","prototype","writable","parser","completeParse","packets","_clearReconnect","push","nextTickWork","work","done","_handlePacket","_write","buf","enc","parse","streamErrorHandler","message","includes","code","pipe","connectPacket","create","max","bind","authenticationMethod","authenticationData","end","authPacket","reasonCode","setMaxListeners","_cleanUp","maximumPacketSize","reasonString","_handlePublish","_handleAck","_handlePubrel","_handleConnack","_handleAuth","_handlePingresp","_handleDisconnect","_checkDisconnecting","publish","opts","defaultOpts","qos","retain","dup","publishProc","_nextId","payload","invoke","subscribe","args","Array","i","subs","obj","pop","version","invalidTopic","validateTopics","nl","rap","rh","isArray","hasOwnProperty","currentOpts","subscribeProc","subscriptions","topics","sub","granted","unsubscribe","unsubscribeProc","unsubscriptions","force","closeStores","disconnected","close","e1","e2","_deferredReconnect","finish","removeOutgoingMessage","del","reconnect","f","_reconnect","reconnecting","setInterval","clearInterval","forced","destroy","removeListener","_shiftPingInterval","_storePacket","_setupPingTimer","pingResp","_checkPing","reschedule","rc","returnCode","serverKeepAlive","_onConnect","handleAuth","validReasonCodes","gotTopic","indexOf","handleMessage","type","response","pubackRC","deallocate","_invokeStoreProcessingQueue","pubrecRC","grantedI","comp","get","pub","allocate","getLastMessageId","getLastAllocated","_resubscribeTopicsKeys","connackPacket","sessionPresent","topicI","resubscribeTopic","startStreamProcess","outStore","createStream","clearStoreProcessing","remove","_flushStoreProcessingQueue","storeDeliver","read","status","allProcessed","id","_invokeAllStoreProcessingQueue","splice","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/**\n * Module dependencies\n */\nconst EventEmitter = require('events').EventEmitter\nconst Store = require('./store')\nconst TopicAliasRecv = require('./topic-alias-recv')\nconst TopicAliasSend = require('./topic-alias-send')\nconst mqttPacket = require('mqtt-packet')\nconst DefaultMessageIdProvider = require('./default-message-id-provider')\nconst Writable = require('readable-stream').Writable\nconst inherits = require('inherits')\nconst reInterval = require('reinterval')\nconst clone = require('rfdc/default')\nconst validations = require('./validations')\nconst xtend = require('xtend')\nconst debug = require('debug')('mqttjs:client')\nconst nextTick = process ? process.nextTick : function (callback) { setTimeout(callback, 0) }\nconst setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  nextTick(callback)\n}\nconst defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n}\n\nconst socketErrors = [\n  'ECONNREFUSED',\n  'EADDRINUSE',\n  'ECONNRESET',\n  'ENOTFOUND'\n]\n\n// Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\nconst errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n}\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n}\n\nfunction applyTopicAlias (client, packet) {\n  if (client.options.protocolVersion === 5) {\n    if (packet.cmd === 'publish') {\n      let alias\n      if (packet.properties) {\n        alias = packet.properties.topicAlias\n      }\n      const topic = packet.topic.toString()\n      if (client.topicAliasSend) {\n        if (alias) {\n          if (topic.length !== 0) {\n            // register topic alias\n            debug('applyTopicAlias :: register topic: %s - alias: %d', topic, alias)\n            if (!client.topicAliasSend.put(topic, alias)) {\n              debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias)\n              return new Error('Sending Topic Alias out of range')\n            }\n          }\n        } else {\n          if (topic.length !== 0) {\n            if (client.options.autoAssignTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic)\n              if (alias) {\n                packet.topic = ''\n                packet.properties = { ...(packet.properties), topicAlias: alias }\n                debug('applyTopicAlias :: auto assign(use) topic: %s - alias: %d', topic, alias)\n              } else {\n                alias = client.topicAliasSend.getLruAlias()\n                client.topicAliasSend.put(topic, alias)\n                packet.properties = { ...(packet.properties), topicAlias: alias }\n                debug('applyTopicAlias :: auto assign topic: %s - alias: %d', topic, alias)\n              }\n            } else if (client.options.autoUseTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic)\n              if (alias) {\n                packet.topic = ''\n                packet.properties = { ...(packet.properties), topicAlias: alias }\n                debug('applyTopicAlias :: auto use topic: %s - alias: %d', topic, alias)\n              }\n            }\n          }\n        }\n      } else if (alias) {\n        debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias)\n        return new Error('Sending Topic Alias out of range')\n      }\n    }\n  }\n}\n\nfunction removeTopicAliasAndRecoverTopicName (client, packet) {\n  let alias\n  if (packet.properties) {\n    alias = packet.properties.topicAlias\n  }\n\n  let topic = packet.topic.toString()\n  if (topic.length === 0) {\n    // restore topic from alias\n    if (typeof alias === 'undefined') {\n      return new Error('Unregistered Topic Alias')\n    } else {\n      topic = client.topicAliasSend.getTopicByAlias(alias)\n      if (typeof topic === 'undefined') {\n        return new Error('Unregistered Topic Alias')\n      } else {\n        packet.topic = topic\n      }\n    }\n  }\n  if (alias) {\n    delete packet.properties.topicAlias\n  }\n}\n\nfunction sendPacket (client, packet, cb) {\n  debug('sendPacket :: packet: %O', packet)\n  debug('sendPacket :: emitting `packetsend`')\n\n  client.emit('packetsend', packet)\n\n  debug('sendPacket :: writing to stream')\n  const result = mqttPacket.writeToStream(packet, client.stream, client.options)\n  debug('sendPacket :: writeToStream result %s', result)\n  if (!result && cb && cb !== nop) {\n    debug('sendPacket :: handle events on `drain` once through callback.')\n    client.stream.once('drain', cb)\n  } else if (cb) {\n    debug('sendPacket :: invoking cb')\n    cb()\n  }\n}\n\nfunction flush (queue) {\n  if (queue) {\n    debug('flush: queue exists? %b', !!(queue))\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        // This is suspicious.  Why do we only delete this if we have a callbck?\n        // If this is by-design, then adding no as callback would cause this to get deleted unintentionally.\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction flushVolatile (queue) {\n  if (queue) {\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function')\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction storeAndSend (client, packet, cb, cbStorePut) {\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd)\n  let storePacket = packet\n  let err\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet)\n    err = removeTopicAliasAndRecoverTopicName(client, storePacket)\n    if (err) {\n      return cb && cb(err)\n    }\n  }\n  client.outgoingStore.put(storePacket, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err)\n    }\n    cbStorePut()\n    sendPacket(client, packet, cb)\n  })\n}\n\nfunction nop (error) {\n  debug('nop ::', error)\n}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  let k\n  const that = this\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k]\n    } else {\n      this.options[k] = options[k]\n    }\n  }\n\n  debug('MqttClient :: options.protocol', options.protocol)\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion)\n  debug('MqttClient :: options.username', options.username)\n  debug('MqttClient :: options.keepalive', options.keepalive)\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod)\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized)\n  debug('MqttClient :: options.topicAliasMaximum', options.topicAliasMaximum)\n\n  this.options.clientId = (typeof options.clientId === 'string') ? options.clientId : defaultId()\n\n  debug('MqttClient :: clientId', this.options.clientId)\n\n  this.options.customHandleAcks = (options.protocolVersion === 5 && options.customHandleAcks) ? options.customHandleAcks : function () { arguments[3](0) }\n\n  this.streamBuilder = streamBuilder\n\n  this.messageIdProvider = (typeof this.options.messageIdProvider === 'undefined') ? new DefaultMessageIdProvider() : this.options.messageIdProvider\n\n  // Inflight message storages\n  this.outgoingStore = options.outgoingStore || new Store()\n  this.incomingStore = options.incomingStore || new Store()\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {}\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {}\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null\n  // Is the client connected?\n  this.connected = false\n  // Are we disconnecting?\n  this.disconnecting = false\n  // Packet queue\n  this.queue = []\n  // connack timer\n  this.connackTimer = null\n  // Reconnect timer\n  this.reconnectTimer = null\n  // Is processing store?\n  this._storeProcessing = false\n  // Packet Ids are put into the store during store processing\n  this._packetIdsDuringStoreProcessing = {}\n  // Store processing queue\n  this._storeProcessingQueue = []\n\n  // Inflight callbacks\n  this.outgoing = {}\n\n  // True if connection is first time.\n  this._firstConnection = true\n\n  if (options.topicAliasMaximum > 0) {\n    if (options.topicAliasMaximum > 0xffff) {\n      debug('MqttClient :: options.topicAliasMaximum is out of range')\n    } else {\n      this.topicAliasRecv = new TopicAliasRecv(options.topicAliasMaximum)\n    }\n  }\n\n  // Send queued packets\n  this.on('connect', function () {\n    const queue = this.queue\n\n    function deliver () {\n      const entry = queue.shift()\n      debug('deliver :: entry %o', entry)\n      let packet = null\n\n      if (!entry) {\n        that._resubscribe()\n        return\n      }\n\n      packet = entry.packet\n      debug('deliver :: call _sendPacket for %o', packet)\n      let send = true\n      if (packet.messageId && packet.messageId !== 0) {\n        if (!that.messageIdProvider.register(packet.messageId)) {\n          send = false\n        }\n      }\n      if (send) {\n        that._sendPacket(\n          packet,\n          function (err) {\n            if (entry.cb) {\n              entry.cb(err)\n            }\n            deliver()\n          }\n        )\n      } else {\n        debug('messageId: %d has already used. The message is skipped and removed.', packet.messageId)\n        deliver()\n      }\n    }\n\n    debug('connect :: sending queued packets')\n    deliver()\n  })\n\n  this.on('close', function () {\n    debug('close :: connected set to `false`')\n    this.connected = false\n\n    debug('close :: clearing connackTimer')\n    clearTimeout(this.connackTimer)\n\n    debug('close :: clearing ping timer')\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear()\n      that.pingTimer = null\n    }\n\n    if (this.topicAliasRecv) {\n      this.topicAliasRecv.clear()\n    }\n\n    debug('close :: calling _setupReconnect')\n    this._setupReconnect()\n  })\n  EventEmitter.call(this)\n\n  debug('MqttClient :: setting up stream')\n  this._setupStream()\n}\ninherits(MqttClient, EventEmitter)\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  const that = this\n  const writable = new Writable()\n  const parser = mqttPacket.parser(this.options)\n  let completeParse = null\n  const packets = []\n\n  debug('_setupStream :: calling method to clear reconnect')\n  this._clearReconnect()\n\n  debug('_setupStream :: using streamBuilder provided to client to create stream')\n  this.stream = this.streamBuilder(this)\n\n  parser.on('packet', function (packet) {\n    debug('parser :: on packet push to packets array.')\n    packets.push(packet)\n  })\n\n  function nextTickWork () {\n    if (packets.length) {\n      nextTick(work)\n    } else {\n      const done = completeParse\n      completeParse = null\n      done()\n    }\n  }\n\n  function work () {\n    debug('work :: getting next packet in queue')\n    const packet = packets.shift()\n\n    if (packet) {\n      debug('work :: packet pulled from queue')\n      that._handlePacket(packet, nextTickWork)\n    } else {\n      debug('work :: no packets in queue')\n      const done = completeParse\n      completeParse = null\n      debug('work :: done flag is %s', !!(done))\n      if (done) done()\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done\n    debug('writable stream :: parsing buffer')\n    parser.parse(buf)\n    work()\n  }\n\n  function streamErrorHandler (error) {\n    debug('streamErrorHandler :: error', error.message)\n    if (socketErrors.includes(error.code)) {\n      // handle error\n      debug('streamErrorHandler :: emitting error')\n      that.emit('error', error)\n    } else {\n      nop(error)\n    }\n  }\n\n  debug('_setupStream :: pipe stream to writable stream')\n  this.stream.pipe(writable)\n\n  // Suppress connection errors\n  this.stream.on('error', streamErrorHandler)\n\n  // Echo stream close\n  this.stream.on('close', function () {\n    debug('(%s)stream :: on close', that.options.clientId)\n    flushVolatile(that.outgoing)\n    debug('stream: emit close to MqttClient')\n    that.emit('close')\n  })\n\n  // Send a connect packet\n  debug('_setupStream: sending packet `connect`')\n  const connectPacket = Object.create(this.options)\n  connectPacket.cmd = 'connect'\n  if (this.topicAliasRecv) {\n    if (!connectPacket.properties) {\n      connectPacket.properties = {}\n    }\n    if (this.topicAliasRecv) {\n      connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max\n    }\n  }\n  // avoid message queue\n  sendPacket(this, connectPacket)\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'))\n\n  // auth\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      that.end(() =>\n        this.emit('error', new Error('Packet has no Authentication Method')\n        ))\n      return this\n    }\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      const authPacket = xtend({ cmd: 'auth', reasonCode: 0 }, this.options.authPacket)\n      sendPacket(this, authPacket)\n    }\n  }\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000)\n\n  clearTimeout(this.connackTimer)\n  this.connackTimer = setTimeout(function () {\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`')\n    that._cleanUp(true)\n  }, this.options.connectTimeout)\n}\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  const options = this.options\n\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd))\n    this.end({ reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' } })\n    return this\n  }\n  debug('_handlePacket :: emitting packetreceive')\n  this.emit('packetreceive', packet)\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done)\n      break\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet)\n      done()\n      break\n    case 'pubrel':\n      this._handlePubrel(packet, done)\n      break\n    case 'connack':\n      this._handleConnack(packet)\n      done()\n      break\n    case 'auth':\n      this._handleAuth(packet)\n      done()\n      break\n    case 'pingresp':\n      this._handlePingresp(packet)\n      done()\n      break\n    case 'disconnect':\n      this._handleDisconnect(packet)\n      done()\n      break\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break\n  }\n}\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback && callback !== nop) {\n      callback(new Error('client disconnecting'))\n    } else {\n      this.emit('error', new Error('client disconnecting'))\n    }\n  }\n  return this.disconnecting\n}\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  debug('publish :: message `%s` to topic `%s`', message, topic)\n  const options = this.options\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = null\n  }\n\n  // default opts\n  const defaultOpts = { qos: 0, retain: false, dup: false }\n  opts = xtend(defaultOpts, opts)\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  const that = this\n  const publishProc = function () {\n    let messageId = 0\n    if (opts.qos === 1 || opts.qos === 2) {\n      messageId = that._nextId()\n      if (messageId === null) {\n        debug('No messageId left')\n        return false\n      }\n    }\n    const packet = {\n      cmd: 'publish',\n      topic: topic,\n      payload: message,\n      qos: opts.qos,\n      retain: opts.retain,\n      messageId: messageId,\n      dup: opts.dup\n    }\n\n    if (options.protocolVersion === 5) {\n      packet.properties = opts.properties\n    }\n\n    debug('publish :: qos', opts.qos)\n    switch (opts.qos) {\n      case 1:\n      case 2:\n        // Add to callbacks\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: callback || nop\n        }\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\n        that._sendPacket(packet, undefined, opts.cbStorePut)\n        break\n      default:\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\n        that._sendPacket(packet, callback, opts.cbStorePut)\n        break\n    }\n    return true\n  }\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {\n    this._storeProcessingQueue.push(\n      {\n        invoke: publishProc,\n        cbStorePut: opts.cbStorePut,\n        callback: callback\n      }\n    )\n  }\n  return this\n}\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  const that = this\n  const args = new Array(arguments.length)\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  const subs = []\n  let obj = args.shift()\n  const resubscribe = obj.resubscribe\n  let callback = args.pop() || nop\n  let opts = args.pop()\n  const version = this.options.protocolVersion\n\n  delete obj.resubscribe\n\n  if (typeof obj === 'string') {\n    obj = [obj]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  const invalidTopic = validations.validateTopics(obj)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    debug('subscribe: discconecting true')\n    return this\n  }\n\n  const defaultOpts = {\n    qos: 0\n  }\n  if (version === 5) {\n    defaultOpts.nl = false\n    defaultOpts.rap = false\n    defaultOpts.rh = 0\n  }\n  opts = xtend(defaultOpts, opts)\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      debug('subscribe: array topic %s', topic)\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, topic) ||\n        that._resubscribeTopics[topic].qos < opts.qos ||\n          resubscribe) {\n        const currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        }\n        if (version === 5) {\n          currentOpts.nl = opts.nl\n          currentOpts.rap = opts.rap\n          currentOpts.rh = opts.rh\n          currentOpts.properties = opts.properties\n        }\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos)\n        subs.push(currentOpts)\n      }\n    })\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        debug('subscribe: object topic %s', k)\n        if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, k) ||\n          that._resubscribeTopics[k].qos < obj[k].qos ||\n            resubscribe) {\n          const currentOpts = {\n            topic: k,\n            qos: obj[k].qos\n          }\n          if (version === 5) {\n            currentOpts.nl = obj[k].nl\n            currentOpts.rap = obj[k].rap\n            currentOpts.rh = obj[k].rh\n            currentOpts.properties = opts.properties\n          }\n          debug('subscribe: pushing `%s` to subs list', currentOpts)\n          subs.push(currentOpts)\n        }\n      })\n  }\n\n  if (!subs.length) {\n    callback(null, [])\n    return this\n  }\n\n  const subscribeProc = function () {\n    const messageId = that._nextId()\n    if (messageId === null) {\n      debug('No messageId left')\n      return false\n    }\n\n    const packet = {\n      cmd: 'subscribe',\n      subscriptions: subs,\n      qos: 1,\n      retain: false,\n      dup: false,\n      messageId: messageId\n    }\n\n    if (opts.properties) {\n      packet.properties = opts.properties\n    }\n\n    // subscriptions to resubscribe to in case of disconnect\n    if (that.options.resubscribe) {\n      debug('subscribe :: resubscribe true')\n      const topics = []\n      subs.forEach(function (sub) {\n        if (that.options.reconnectPeriod > 0) {\n          const topic = { qos: sub.qos }\n          if (version === 5) {\n            topic.nl = sub.nl || false\n            topic.rap = sub.rap || false\n            topic.rh = sub.rh || 0\n            topic.properties = sub.properties\n          }\n          that._resubscribeTopics[sub.topic] = topic\n          topics.push(sub.topic)\n        }\n      })\n      that.messageIdToTopic[packet.messageId] = topics\n    }\n\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: function (err, packet) {\n        if (!err) {\n          const granted = packet.granted\n          for (let i = 0; i < granted.length; i += 1) {\n            subs[i].qos = granted[i]\n          }\n        }\n\n        callback(err, subs)\n      }\n    }\n    debug('subscribe :: call _sendPacket')\n    that._sendPacket(packet)\n    return true\n  }\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {\n    this._storeProcessingQueue.push(\n      {\n        invoke: subscribeProc,\n        callback: callback\n      }\n    )\n  }\n\n  return this\n}\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Object} properties - properties of unsubscribe packet\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function () {\n  const that = this\n  const args = new Array(arguments.length)\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  let topic = args.shift()\n  let callback = args.pop() || nop\n  let opts = args.pop()\n  if (typeof topic === 'string') {\n    topic = [topic]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  const invalidTopic = validations.validateTopics(topic)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (that._checkDisconnecting(callback)) {\n    return this\n  }\n\n  const unsubscribeProc = function () {\n    const messageId = that._nextId()\n    if (messageId === null) {\n      debug('No messageId left')\n      return false\n    }\n    const packet = {\n      cmd: 'unsubscribe',\n      qos: 1,\n      messageId: messageId\n    }\n\n    if (typeof topic === 'string') {\n      packet.unsubscriptions = [topic]\n    } else if (Array.isArray(topic)) {\n      packet.unsubscriptions = topic\n    }\n\n    if (that.options.resubscribe) {\n      packet.unsubscriptions.forEach(function (topic) {\n        delete that._resubscribeTopics[topic]\n      })\n    }\n\n    if (typeof opts === 'object' && opts.properties) {\n      packet.properties = opts.properties\n    }\n\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: callback\n    }\n\n    debug('unsubscribe: call _sendPacket')\n    that._sendPacket(packet)\n\n    return true\n  }\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {\n    this._storeProcessingQueue.push(\n      {\n        invoke: unsubscribeProc,\n        callback: callback\n      }\n    )\n  }\n\n  return this\n}\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Object} opts - added to the disconnect packet\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, opts, cb) {\n  const that = this\n\n  debug('end :: (%s)', this.options.clientId)\n\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop\n    opts = force\n    force = false\n    if (typeof opts !== 'object') {\n      cb = opts\n      opts = null\n      if (typeof cb !== 'function') {\n        cb = nop\n      }\n    }\n  }\n\n  if (typeof opts !== 'object') {\n    cb = opts\n    opts = null\n  }\n\n  debug('end :: cb? %s', !!cb)\n  cb = cb || nop\n\n  function closeStores () {\n    debug('end :: closeStores: closing incoming and outgoing stores')\n    that.disconnected = true\n    that.incomingStore.close(function (e1) {\n      that.outgoingStore.close(function (e2) {\n        debug('end :: closeStores: emitting end')\n        that.emit('end')\n        if (cb) {\n          const err = e1 || e2\n          debug('end :: closeStores: invoking callback with args')\n          cb(err)\n        }\n      })\n    })\n    if (that._deferredReconnect) {\n      that._deferredReconnect()\n    }\n  }\n\n  function finish () {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force)\n    that._cleanUp(force, () => {\n      debug('end :: finish :: calling process.nextTick on closeStores')\n      // const boundProcess = nextTick.bind(null, closeStores)\n      nextTick(closeStores.bind(that))\n    }, opts)\n  }\n\n  if (this.disconnecting) {\n    cb()\n    return this\n  }\n\n  this._clearReconnect()\n\n  this.disconnecting = true\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId)\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n  } else {\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId)\n    finish()\n  }\n\n  return this\n}\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} messageId - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastAllocated());\n */\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\n  delete this.outgoing[messageId]\n  this.outgoingStore.del({ messageId: messageId }, function () {\n    cb(new Error('Message removed'))\n  })\n  return this\n}\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  debug('client reconnect')\n  const that = this\n  const f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore\n      that.options.outgoingStore = opts.outgoingStore\n    } else {\n      that.options.incomingStore = null\n      that.options.outgoingStore = null\n    }\n    that.incomingStore = that.options.incomingStore || new Store()\n    that.outgoingStore = that.options.outgoingStore || new Store()\n    that.disconnecting = false\n    that.disconnected = false\n    that._deferredReconnect = null\n    that._reconnect()\n  }\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f\n  } else {\n    f()\n  }\n  return this\n}\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  debug('_reconnect: emitting reconnect to client')\n  this.emit('reconnect')\n  if (this.connected) {\n    this.end(() => { this._setupStream() })\n    debug('client already connected. disconnecting first.')\n  } else {\n    debug('_reconnect: calling _setupStream')\n    this._setupStream()\n  }\n}\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  const that = this\n\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\n    if (!this.reconnecting) {\n      debug('_setupReconnect :: emit `offline` state')\n      this.emit('offline')\n      debug('_setupReconnect :: set `reconnecting` to `true`')\n      this.reconnecting = true\n    }\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod)\n    that.reconnectTimer = setInterval(function () {\n      debug('reconnectTimer :: reconnect triggered!')\n      that._reconnect()\n    }, that.options.reconnectPeriod)\n  } else {\n    debug('_setupReconnect :: doing nothing...')\n  }\n}\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  debug('_clearReconnect : clearing reconnect timer')\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer)\n    this.reconnectTimer = null\n  }\n}\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  const opts = arguments[2]\n  if (done) {\n    debug('_cleanUp :: done callback provided for on stream close')\n    this.stream.on('close', done)\n  }\n\n  debug('_cleanUp :: forced? %s', forced)\n  if (forced) {\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\n      flush(this.outgoing)\n    }\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId)\n    this.stream.destroy()\n  } else {\n    const packet = xtend({ cmd: 'disconnect' }, opts)\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId)\n    this._sendPacket(\n      packet,\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    )\n  }\n\n  if (!this.disconnecting) {\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.')\n    this._clearReconnect()\n    this._setupReconnect()\n  }\n\n  if (this.pingTimer !== null) {\n    debug('_cleanUp :: clearing pingTimer')\n    this.pingTimer.clear()\n    this.pingTimer = null\n  }\n\n  if (done && !this.connected) {\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId)\n    this.stream.removeListener('close', done)\n    done()\n  }\n}\n\n/**\n * _sendPacket - send or queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId)\n  cbStorePut = cbStorePut || nop\n  cb = cb || nop\n\n  const err = applyTopicAlias(this, packet)\n  if (err) {\n    cb(err)\n    return\n  }\n\n  if (!this.connected) {\n    // allow auth packets to be sent while authenticating with the broker (mqtt5 enhanced auth)\n    if (packet.cmd === 'auth') {\n      this._shiftPingInterval()\n      sendPacket(this, packet, cb)\n      return\n    }\n\n    debug('_sendPacket :: client not connected. Storing packet offline.')\n    this._storePacket(packet, cb, cbStorePut)\n    return\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval()\n\n  switch (packet.cmd) {\n    case 'publish':\n      break\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut)\n      return\n    default:\n      sendPacket(this, packet, cb)\n      return\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut)\n      break\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb)\n      break\n  }\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId)\n}\n\n/**\n * _storePacket - queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  debug('_storePacket :: packet: %o', packet)\n  debug('_storePacket :: cb? %s', !!cb)\n  cbStorePut = cbStorePut || nop\n\n  let storePacket = packet\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet)\n    const err = removeTopicAliasAndRecoverTopicName(this, storePacket)\n    if (err) {\n      return cb && cb(err)\n    }\n  }\n  // check that the packet is not a qos of 0, or that the command is not a publish\n  if (((storePacket.qos || 0) === 0 && this.queueQoSZero) || storePacket.cmd !== 'publish') {\n    this.queue.push({ packet: storePacket, cb: cb })\n  } else if (storePacket.qos > 0) {\n    cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null\n    this.outgoingStore.put(storePacket, function (err) {\n      if (err) {\n        return cb && cb(err)\n      }\n      cbStorePut()\n    })\n  } else if (cb) {\n    cb(new Error('No connection to broker'))\n  }\n}\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive)\n  const that = this\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true\n    this.pingTimer = reInterval(function () {\n      that._checkPing()\n    }, this.options.keepalive * 1000)\n  }\n}\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\n  }\n}\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  debug('_checkPing :: checking ping...')\n  if (this.pingResp) {\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`')\n    this.pingResp = false\n    this._sendPacket({ cmd: 'pingreq' })\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    debug('_checkPing :: calling _cleanUp with force true')\n    this._cleanUp(true)\n  }\n}\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true\n}\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleConnack = function (packet) {\n  debug('_handleConnack')\n  const options = this.options\n  const version = options.protocolVersion\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode\n\n  clearTimeout(this.connackTimer)\n  delete this.topicAliasSend\n\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (packet.properties.topicAliasMaximum > 0xffff) {\n        this.emit('error', new Error('topicAliasMaximum from broker is out of range'))\n        return\n      }\n      if (packet.properties.topicAliasMaximum > 0) {\n        this.topicAliasSend = new TopicAliasSend(packet.properties.topicAliasMaximum)\n      }\n    }\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive\n      this._shiftPingInterval()\n    }\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) { options.properties = {} }\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize\n    }\n  }\n\n  if (rc === 0) {\n    this.reconnecting = false\n    this._onConnect(packet)\n  } else if (rc > 0) {\n    const err = new Error('Connection refused: ' + errors[rc])\n    err.code = rc\n    this.emit('error', err)\n  }\n}\n\nMqttClient.prototype._handleAuth = function (packet) {\n  const options = this.options\n  const version = options.protocolVersion\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode\n\n  if (version !== 5) {\n    const err = new Error('Protocol error: Auth packets are only supported in MQTT 5. Your version:' + version)\n    err.code = rc\n    this.emit('error', err)\n    return\n  }\n\n  const that = this\n  this.handleAuth(packet, function (err, packet) {\n    if (err) {\n      that.emit('error', err)\n      return\n    }\n\n    if (rc === 24) {\n      that.reconnecting = false\n      that._sendPacket(packet)\n    } else {\n      const error = new Error('Connection refused: ' + errors[rc])\n      err.code = rc\n      that.emit('error', error)\n    }\n  })\n}\n\n/**\n * @param packet the packet received by the broker\n * @return the auth packet to be returned to the broker\n * @api public\n */\nMqttClient.prototype.handleAuth = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: messageId\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  debug('_handlePublish: packet %o', packet)\n  done = typeof done !== 'undefined' ? done : nop\n  let topic = packet.topic.toString()\n  const message = packet.payload\n  const qos = packet.qos\n  const messageId = packet.messageId\n  const that = this\n  const options = this.options\n  const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153]\n  if (this.options.protocolVersion === 5) {\n    let alias\n    if (packet.properties) {\n      alias = packet.properties.topicAlias\n    }\n    if (typeof alias !== 'undefined') {\n      if (topic.length === 0) {\n        if (alias > 0 && alias <= 0xffff) {\n          const gotTopic = this.topicAliasRecv.getTopicByAlias(alias)\n          if (gotTopic) {\n            topic = gotTopic\n            debug('_handlePublish :: topic complemented by alias. topic: %s - alias: %d', topic, alias)\n          } else {\n            debug('_handlePublish :: unregistered topic alias. alias: %d', alias)\n            this.emit('error', new Error('Received unregistered Topic Alias'))\n            return\n          }\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias)\n          this.emit('error', new Error('Received Topic Alias is out of range'))\n          return\n        }\n      } else {\n        if (this.topicAliasRecv.put(topic, alias)) {\n          debug('_handlePublish :: registered topic: %s - alias: %d', topic, alias)\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias)\n          this.emit('error', new Error('Received Topic Alias is out of range'))\n          return\n        }\n      }\n    }\n  }\n  debug('_handlePublish: qos %d', qos)\n  switch (qos) {\n    case 2: {\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for pubrec')) }\n        if (code) {\n          that._sendPacket({ cmd: 'pubrec', messageId: messageId, reasonCode: code }, done)\n        } else {\n          that.incomingStore.put(packet, function () {\n            that._sendPacket({ cmd: 'pubrec', messageId: messageId }, done)\n          })\n        }\n      })\n      break\n    }\n    case 1: {\n      // emit the message event\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for puback')) }\n        if (!code) { that.emit('message', topic, message, packet) }\n        that.handleMessage(packet, function (err) {\n          if (err) {\n            return done && done(err)\n          }\n          that._sendPacket({ cmd: 'puback', messageId: messageId, reasonCode: code }, done)\n        })\n      })\n      break\n    }\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, done)\n      break\n    default:\n      // do nothing\n      debug('_handlePublish: unknown QoS. Doing nothing.')\n      // log or throw an error about unknown qos\n      break\n  }\n}\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  const messageId = packet.messageId\n  const type = packet.cmd\n  let response = null\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\n  const that = this\n  let err\n\n  if (!cb || cb === nop) {\n    debug('_handleAck :: Server sent an ack in error. Ignoring.')\n    // Server sent an ack in error, ignore it.\n    return\n  }\n\n  // Process\n  debug('_handleAck :: packet type', type)\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback': {\n      const pubackRC = packet.reasonCode\n      // Callback - we're done\n      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubackRC])\n        err.code = pubackRC\n        cb(err, packet)\n      }\n      delete this.outgoing[messageId]\n      this.outgoingStore.del(packet, cb)\n      this.messageIdProvider.deallocate(messageId)\n      this._invokeStoreProcessingQueue()\n      break\n    }\n    case 'pubrec': {\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: messageId\n      }\n      const pubrecRC = packet.reasonCode\n\n      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubrecRC])\n        err.code = pubrecRC\n        cb(err, packet)\n      } else {\n        this._sendPacket(response)\n      }\n      break\n    }\n    case 'suback': {\n      delete this.outgoing[messageId]\n      this.messageIdProvider.deallocate(messageId)\n      for (let grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n        if ((packet.granted[grantedI] & 0x80) !== 0) {\n          // suback with Failure status\n          const topics = this.messageIdToTopic[messageId]\n          if (topics) {\n            topics.forEach(function (topic) {\n              delete that._resubscribeTopics[topic]\n            })\n          }\n        }\n      }\n      this._invokeStoreProcessingQueue()\n      cb(null, packet)\n      break\n    }\n    case 'unsuback': {\n      delete this.outgoing[messageId]\n      this.messageIdProvider.deallocate(messageId)\n      this._invokeStoreProcessingQueue()\n      cb(null)\n      break\n    }\n    default:\n      that.emit('error', new Error('unrecognized packet type'))\n  }\n\n  if (this.disconnecting &&\n      Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty')\n  }\n}\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  debug('handling pubrel packet')\n  callback = typeof callback !== 'undefined' ? callback : nop\n  const messageId = packet.messageId\n  const that = this\n\n  const comp = { cmd: 'pubcomp', messageId: messageId }\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub)\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err)\n        }\n        that.incomingStore.del(pub, nop)\n        that._sendPacket(comp, callback)\n      })\n    } else {\n      that._sendPacket(comp, callback)\n    }\n  })\n}\n\n/**\n * _handleDisconnect\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet)\n}\n\n/**\n * _nextId\n * @return unsigned int\n */\nMqttClient.prototype._nextId = function () {\n  return this.messageIdProvider.allocate()\n}\n\n/**\n * getLastMessageId\n * @return unsigned int\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return this.messageIdProvider.getLastAllocated()\n}\n\n/**\n * _resubscribe\n * @api private\n */\nMqttClient.prototype._resubscribe = function () {\n  debug('_resubscribe')\n  const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)\n  if (!this._firstConnection &&\n      (this.options.clean || (this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent)) &&\n      _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        debug('_resubscribe: protocolVersion 5')\n        for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          const resubscribeTopic = {}\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]]\n          resubscribeTopic.resubscribe = true\n          this.subscribe(resubscribeTopic, { properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties })\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true\n        this.subscribe(this._resubscribeTopics)\n      }\n    } else {\n      this._resubscribeTopics = {}\n    }\n  }\n\n  this._firstConnection = false\n}\n\n/**\n * _onConnect\n *\n * @api private\n */\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet)\n    return\n  }\n\n  const that = this\n\n  this.connackPacket = packet\n  this.messageIdProvider.clear()\n  this._setupPingTimer()\n\n  this.connected = true\n\n  function startStreamProcess () {\n    let outStore = that.outgoingStore.createStream()\n\n    function clearStoreProcessing () {\n      that._storeProcessing = false\n      that._packetIdsDuringStoreProcessing = {}\n    }\n\n    that.once('close', remove)\n    outStore.on('error', function (err) {\n      clearStoreProcessing()\n      that._flushStoreProcessingQueue()\n      that.removeListener('close', remove)\n      that.emit('error', err)\n    })\n\n    function remove () {\n      outStore.destroy()\n      outStore = null\n      that._flushStoreProcessingQueue()\n      clearStoreProcessing()\n    }\n\n    function storeDeliver () {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return\n      }\n      that._storeProcessing = true\n\n      const packet = outStore.read(1)\n\n      let cb\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver)\n        return\n      }\n\n      // Skip already processed store packets\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver()\n        return\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status)\n            }\n\n            storeDeliver()\n          }\n        }\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true\n        if (that.messageIdProvider.register(packet.messageId)) {\n          that._sendPacket(packet)\n        } else {\n          debug('messageId: %d has already used.', packet.messageId)\n        }\n      } else if (outStore.destroy) {\n        outStore.destroy()\n      }\n    }\n\n    outStore.on('end', function () {\n      let allProcessed = true\n      for (const id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false\n          break\n        }\n      }\n      if (allProcessed) {\n        clearStoreProcessing()\n        that.removeListener('close', remove)\n        that._invokeAllStoreProcessingQueue()\n        that.emit('connect', packet)\n      } else {\n        startStreamProcess()\n      }\n    })\n    storeDeliver()\n  }\n  // start flowing\n  startStreamProcess()\n}\n\nMqttClient.prototype._invokeStoreProcessingQueue = function () {\n  if (this._storeProcessingQueue.length > 0) {\n    const f = this._storeProcessingQueue[0]\n    if (f && f.invoke()) {\n      this._storeProcessingQueue.shift()\n      return true\n    }\n  }\n  return false\n}\n\nMqttClient.prototype._invokeAllStoreProcessingQueue = function () {\n  while (this._invokeStoreProcessingQueue()) { /* empty */ }\n}\n\nMqttClient.prototype._flushStoreProcessingQueue = function () {\n  for (const f of this._storeProcessingQueue) {\n    if (f.cbStorePut) f.cbStorePut(new Error('Connection closed'))\n    if (f.callback) f.callback(new Error('Connection closed'))\n  }\n  this._storeProcessingQueue.splice(0)\n}\n\nmodule.exports = MqttClient\n"]},"metadata":{},"sourceType":"script"}